"""
Vulnerability Scanner
Checks for known vulnerabilities and CVEs
"""

import socket
import struct
import re
from typing import Dict, List, Optional
from datetime import datetime

from .base_scanner import BaseScanner, ScanResult, Finding, SeverityLevel


class VulnerabilityScanner(BaseScanner):
    """
    Vulnerability Scanner
    - Known CVE checks
    - Service-specific vulnerability detection
    - Configuration weakness identification
    """
    
    # Known vulnerabilities database
    VULN_DATABASE = {
        'ssh': [
            {
                'cve': 'CVE-2023-48795',
                'name': 'Terrapin Attack',
                'description': 'Prefix truncation attack against SSH protocol',
                'severity': 'MEDIUM',
                'affected_versions': 'Various SSH implementations',
                'check_method': 'algorithm_check',
                'vulnerable_algorithms': ['chacha20-poly1305@openssh.com', 'aes*-gcm@openssh.com']
            },
            {
                'cve': 'CVE-2016-0777',
                'name': 'SSH Roaming Buffer Overflow',
                'description': 'Memory leak in client roaming feature',
                'severity': 'HIGH',
                'affected_versions': 'OpenSSH 5.4-7.1',
                'check_method': 'version_check',
                'version_pattern': r'OpenSSH_([567]\.[0-9])'
            },
        ],
        'vpn': [
            {
                'cve': 'CVE-2023-46805',
                'name': 'Ivanti VPN Authentication Bypass',
                'description': 'Authentication bypass in Ivanti VPN products',
                'severity': 'CRITICAL',
                'affected': 'Ivanti Connect Secure',
                'check_method': 'banner_check',
            },
            {
                'cve': 'CVE-2024-21887',
                'name': 'Ivanti VPN Command Injection',
                'description': 'Command injection vulnerability',
                'severity': 'CRITICAL',
                'affected': 'Ivanti Connect Secure',
                'check_method': 'banner_check',
            },
        ],
        'softether': [
            {
                'cve': 'CVE-2018-20044',
                'name': 'SoftEther Buffer Overflow',
                'description': 'Buffer overflow in VPN client',
                'severity': 'HIGH',
                'affected_versions': '< 4.28',
                'check_method': 'version_check',
            },
            {
                'cve': 'CVE-2019-11868',
                'name': 'SoftEther VPN Gate Heap Overflow',
                'description': 'Heap overflow vulnerability',
                'severity': 'HIGH',
                'affected_versions': '< 4.29',
                'check_method': 'version_check',
            },
        ],
        'ssl': [
            {
                'cve': 'CVE-2014-0160',
                'name': 'Heartbleed',
                'description': 'OpenSSL heartbeat extension memory leak',
                'severity': 'CRITICAL',
                'check_method': 'heartbleed_check',
            },
            {
                'cve': 'CVE-2014-3566',
                'name': 'POODLE',
                'description': 'SSLv3 padding oracle attack',
                'severity': 'HIGH',
                'check_method': 'protocol_check',
            },
        ],
    }
    
    def __init__(self, target: str, timeout: int = 10, verbose: bool = False,
                 service_type: str = 'all'):
        super().__init__(target, timeout, verbose)
        self.service_type = service_type
        
    @property
    def scanner_name(self) -> str:
        return "Vulnerability Scanner"
    
    def _check_heartbleed(self, port: int = 443) -> Dict:
        """Check for Heartbleed vulnerability (CVE-2014-0160)"""
        result = {
            'vulnerable': False,
            'tested': False,
            'error': None
        }
        
        try:
            # Heartbleed test payload
            hello = bytes.fromhex(
                '16030200dc010000d803014f6cddd82d26cd1b1e2b74'
                'f8b8f8e2c8dd8a9d8c8f8d5e5f6e7c6d6e5f7e6d7e6f'
                '8a9b8c9d8e9f9a0b9c0d9e0f0a1b0c1d0e1f1a2b1c2d'
                '1e2f2a3b2c3d2e3f3a4b3c4d3e4f4a5b4c5d4e5f5a6b'
                '5c6d5e6f6a7b6c7d6e7f7a8b7c8d7e8f8a9b8c9d8e9f'
                '9aab9cad9ebfaabbacbdaecfbabcbdcebfcacbcdcecf'
                'dadcddedf0001000'
            )
            
            heartbeat = bytes.fromhex('18030200030140ff')
            
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(self.timeout)
            sock.connect((self.target, port))
            
            sock.send(hello)
            response = sock.recv(1024)
            
            sock.send(heartbeat)
            heartbeat_response = sock.recv(16384)
            
            result['tested'] = True
            
            # If we get a large response, likely vulnerable
            if len(heartbeat_response) > 10:
                result['vulnerable'] = True
            
            sock.close()
            
        except Exception as e:
            result['error'] = str(e)
        
        return result
    
    def _check_ssh_version_vulnerabilities(self, banner: str) -> List[Dict]:
        """Check SSH banner for known vulnerable versions"""
        vulns = []
        
        for vuln in self.VULN_DATABASE.get('ssh', []):
            if vuln.get('check_method') == 'version_check':
                pattern = vuln.get('version_pattern', '')
                if pattern and re.search(pattern, banner, re.IGNORECASE):
                    vulns.append(vuln)
        
        return vulns
    
    def _check_common_misconfigurations(self) -> List[Dict]:
        """Check for common security misconfigurations"""
        misconfigs = []
        
        # Check for open DNS resolver
        try:
            if self._check_port(53, 'udp'):
                # Try to resolve external domain
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(2)
                
                # Simple DNS query for google.com
                query = bytes.fromhex(
                    'abcd01000001000000000000'  # Header
                    '06676f6f676c6503636f6d00'  # google.com
                    '00010001'                   # A record, IN class
                )
                
                sock.sendto(query, (self.target, 53))
                response, _ = sock.recvfrom(1024)
                
                if len(response) > 0:
                    misconfigs.append({
                        'type': 'Open DNS Resolver',
                        'severity': 'HIGH',
                        'description': 'DNS server responds to external queries (potential for DNS amplification attacks)',
                        'recommendation': 'Restrict DNS queries to authorized networks'
                    })
                
                sock.close()
        except:
            pass
        
        # Check for open SNMP
        try:
            if self._check_port(161, 'udp'):
                # Try public community string
                sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
                sock.settimeout(2)
                
                # SNMP v1 get-request with 'public' community
                snmp_query = bytes.fromhex(
                    '302602010004067075626c6963a019020400020100020100300b300906'
                    '052b060102010100'
                )
                
                sock.sendto(snmp_query, (self.target, 161))
                response, _ = sock.recvfrom(1024)
                
                if len(response) > 0:
                    misconfigs.append({
                        'type': 'SNMP Default Community String',
                        'severity': 'HIGH',
                        'description': 'SNMP responds to "public" community string',
                        'recommendation': 'Change default SNMP community strings and use SNMPv3'
                    })
                
                sock.close()
        except:
            pass
        
        return misconfigs
    
    def _check_service_exposure(self) -> Dict:
        """Check for exposed sensitive services"""
        exposed = {}
        
        sensitive_ports = {
            6379: ('Redis', 'Database without authentication'),
            27017: ('MongoDB', 'NoSQL database'),
            9200: ('Elasticsearch', 'Search engine'),
            5601: ('Kibana', 'Analytics dashboard'),
            2375: ('Docker', 'Container engine API'),
            2376: ('Docker TLS', 'Container engine API with TLS'),
            10250: ('Kubernetes Kubelet', 'Container orchestration'),
            8500: ('Consul', 'Service mesh'),
            4243: ('Docker', 'Alternative Docker port'),
        }
        
        for port, (service, description) in sensitive_ports.items():
            if self._check_port(port):
                exposed[port] = {
                    'service': service,
                    'description': description,
                    'severity': 'HIGH'
                }
        
        return exposed
    
    def scan(self) -> ScanResult:
        """Execute vulnerability scan"""
        result = self._init_result()
        
        self.log_progress("Starting vulnerability scan")
        
        # Check Heartbleed on common SSL ports
        for port in [443, 992, 5555, 8443]:
            if self._check_port(port):
                hb_result = self._check_heartbleed(port)
                result.raw_data[f'heartbleed_port_{port}'] = hb_result
                if hb_result.get('vulnerable'):
                    self.log_progress(f"CRITICAL: Heartbleed vulnerability found on port {port}")
        
        # Get SSH banner and check vulnerabilities
        ssh_banner = self._grab_banner(22)
        if ssh_banner:
            result.raw_data['ssh_banner'] = ssh_banner
            ssh_vulns = self._check_ssh_version_vulnerabilities(ssh_banner)
            result.raw_data['ssh_vulnerabilities'] = ssh_vulns
        
        # Check misconfigurations
        misconfigs = self._check_common_misconfigurations()
        result.raw_data['misconfigurations'] = misconfigs
        
        # Check exposed services
        exposed = self._check_service_exposure()
        result.raw_data['exposed_services'] = exposed
        
        # Generate findings
        self._generate_findings(result)
        
        return self._finalize_result(result)
    
    def _generate_findings(self, result: ScanResult) -> None:
        """Generate findings from vulnerability scan"""
        
        # Heartbleed findings
        for key, value in result.raw_data.items():
            if key.startswith('heartbleed_port_') and value.get('vulnerable'):
                port = key.replace('heartbleed_port_', '')
                self._add_finding(result, Finding(
                    title=f"Heartbleed Vulnerability (Port {port})",
                    description="Server is vulnerable to Heartbleed (CVE-2014-0160), allowing memory disclosure.",
                    severity=SeverityLevel.CRITICAL,
                    category="SSL/TLS Vulnerability",
                    recommendation="Update OpenSSL immediately and regenerate all certificates and keys.",
                    evidence=f"Port {port} responds to heartbleed payload",
                    cve_ids=['CVE-2014-0160'],
                    cvss_score=7.5
                ))
        
        # SSH vulnerability findings
        for vuln in result.raw_data.get('ssh_vulnerabilities', []):
            self._add_finding(result, Finding(
                title=f"SSH Vulnerability: {vuln['name']}",
                description=vuln['description'],
                severity=SeverityLevel.HIGH if vuln['severity'] == 'HIGH' else SeverityLevel.MEDIUM,
                category="SSH Security",
                recommendation="Update SSH server to the latest version.",
                evidence=f"Detected version matches pattern for {vuln['cve']}",
                cve_ids=[vuln['cve']]
            ))
        
        # Misconfiguration findings
        for misconfig in result.raw_data.get('misconfigurations', []):
            severity_map = {'HIGH': SeverityLevel.HIGH, 'MEDIUM': SeverityLevel.MEDIUM, 'LOW': SeverityLevel.LOW}
            self._add_finding(result, Finding(
                title=f"Misconfiguration: {misconfig['type']}",
                description=misconfig['description'],
                severity=severity_map.get(misconfig['severity'], SeverityLevel.MEDIUM),
                category="Configuration",
                recommendation=misconfig['recommendation'],
                evidence=misconfig['type']
            ))
        
        # Exposed service findings
        for port, info in result.raw_data.get('exposed_services', {}).items():
            self._add_finding(result, Finding(
                title=f"Exposed Service: {info['service']} (Port {port})",
                description=f"{info['service']} is exposed on port {port}. {info['description']}",
                severity=SeverityLevel.HIGH,
                category="Service Exposure",
                recommendation=f"Restrict access to {info['service']} using firewall rules. "
                               f"Ensure proper authentication is configured.",
                evidence=f"Port {port} is open and responding"
            ))
